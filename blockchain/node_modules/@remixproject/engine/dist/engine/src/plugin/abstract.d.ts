import { Api, EventKey, EventParams, MethodKey, MethodParams, EventCallback, ApiMap, Profile, PluginRequest, PluginApi, IPluginService, PluginBase } from '../../../utils';
export interface RequestParams {
    name: string;
    key: string;
    payload: any[];
}
export interface PluginOptions {
    /** The time to wait for a call to be executed before going to next call in the queue */
    queueTimeout?: number;
}
export declare class Plugin<T extends Api = any, App extends ApiMap = any> implements PluginBase<T, App> {
    profile: Profile<T>;
    activateService: Record<string, () => Promise<any>>;
    protected requestQueue: Array<() => Promise<any>>;
    protected currentRequest: PluginRequest;
    /** Give access to all the plugins registered by the engine */
    protected app: PluginApi<App>;
    protected options: PluginOptions;
    onRegistration?(): void;
    onActivation?(): void;
    onDeactivation?(): void;
    constructor(profile: Profile<T>);
    get name(): string;
    get methods(): Extract<keyof T['methods'], string>[];
    set methods(methods: Extract<keyof T['methods'], string>[]);
    activate(): void;
    deactivate(): void;
    setOptions(options?: Partial<PluginOptions>): void;
    /** Call a method from this plugin */
    protected callPluginMethod(key: string, args: any[]): any;
    /** Add a request to the list of current requests */
    protected addRequest(request: PluginRequest, method: Profile<T>['methods'][number], args: any[]): Promise<unknown>;
    /**
     * Ask the plugin manager if current request can call a specific method
     * @param method The method to call
     * @param message An optional message to show to the user
     */
    askUserPermission(method: MethodKey<T>, message?: string): Promise<boolean>;
    /**
     * Create a service under the client node
     * @param name The name of the service
     * @param service The service
     */
    createService<S extends Record<string, any>>(name: string, service: S): Promise<IPluginService<S>>;
    /**
     * Prepare a service to be lazy loaded
     * @param name The name of the subservice inside this service
     * @param factory A function to create the service on demand
     */
    prepareService<S extends Record<string, any>>(name: string, factory: () => S): () => Promise<IPluginService<S>>;
    /** Listen on an event from another plugin */
    on<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key, cb: EventCallback<App[Name], Key>): void;
    /** Listen once an event from another plugin then remove event listener */
    once<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key, cb: EventCallback<App[Name], Key>): void;
    /** Stop listening on an event from another plugin */
    off<Name extends Extract<keyof App, string>, Key extends EventKey<App[Name]>>(name: Name, key: Key): void;
    /** Call a method of another plugin */
    call<Name extends Extract<keyof App, string>, Key extends MethodKey<App[Name]>>(name: Name, key: Key, ...payload: MethodParams<App[Name], Key>): Promise<ReturnType<App[Name]['methods'][Key]>>;
    /** Emit an event */
    emit<Key extends EventKey<T>>(key: Key, ...payload: EventParams<T, Key>): void;
}

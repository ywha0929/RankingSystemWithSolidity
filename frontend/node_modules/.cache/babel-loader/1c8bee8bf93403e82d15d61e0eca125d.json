{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ywha0929/RankingSystemWithSolidity/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/ywha0929/RankingSystemWithSolidity/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar utils = require('@motionone/utils');\n\nvar stagger = require('../utils/stagger.cjs.js');\n\nvar animateStyle = require('../animate/animate-style.cjs.js');\n\nvar controls = require('../animate/utils/controls.cjs.js');\n\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\n\nvar options = require('../animate/utils/options.cjs.js');\n\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\n\nvar transforms = require('../animate/utils/transforms.cjs.js');\n\nvar calcTime = require('./utils/calc-time.cjs.js');\n\nvar edit = require('./utils/edit.cjs.js');\n\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\n   * Create and start animations\n   */\n\n  var animationFactories = animationDefinitions.map(function (definition) {\n    return animateStyle.animateStyle.apply(animateStyle, _toConsumableArray(definition));\n  }).filter(Boolean);\n  return controls.withControls(animationFactories, options, // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\n\nfunction createAnimationsFromTimeline(definition) {\n  var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a$defaultOptions = _a.defaultOptions,\n      defaultOptions = _a$defaultOptions === void 0 ? {} : _a$defaultOptions,\n      timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n\n  var animationDefinitions = [];\n  var elementSequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the definition array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n\n  for (var i = 0; i < definition.length; i++) {\n    var segment = definition[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n\n    if (utils.isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n\n    var _segment = _slicedToArray(segment, 3),\n        elementDefinition = _segment[0],\n        keyframes$1 = _segment[1],\n        _segment$ = _segment[2],\n        options$1 = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n\n\n    if (options$1.at !== undefined) {\n      currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n\n\n    var maxDuration = 0;\n    /**\n     * Find all the elements specified in the definition and parse value\n     * keyframes from their timeline definitions.\n     */\n\n    var elements = resolveElements.resolveElements(elementDefinition, elementCache);\n    var numElements = elements.length;\n\n    for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      var element = elements[elementIndex];\n      var elementSequence = getElementSequence(element, elementSequences);\n\n      for (var key in keyframes$1) {\n        var valueSequence = getValueSequence(key, elementSequence);\n        var valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n        var valueOptions = options.getOptions(options$1, key);\n        var _valueOptions$duratio = valueOptions.duration,\n            duration = _valueOptions$duratio === void 0 ? defaultOptions.duration || utils.defaults.duration : _valueOptions$duratio,\n            _valueOptions$easing = valueOptions.easing,\n            easing = _valueOptions$easing === void 0 ? defaultOptions.easing || utils.defaults.easing : _valueOptions$easing;\n\n        if (utils.isEasingGenerator(easing)) {\n          var valueIsTransform = transforms.isTransform(key);\n          heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n          var custom = easing.createAnimation(valueKeyframes, // TODO We currently only support explicit keyframes\n          // so this doesn't currently read from the DOM\n          function () {\n            return \"0\";\n          }, valueIsTransform);\n          easing = custom.easing;\n          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;\n          if (custom.duration !== undefined) duration = custom.duration;\n        }\n\n        var delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n        var startTime = currentTime + delay;\n        var targetTime = startTime + duration;\n        /**\n         *\n         */\n\n        var _valueOptions$offset = valueOptions.offset,\n            offset = _valueOptions$offset === void 0 ? utils.defaultOffset(valueKeyframes.length) : _valueOptions$offset;\n        /**\n         * If there's only one offset of 0, fill in a second with length 1\n         *\n         * TODO: Ensure there's a test that covers this removal\n         */\n\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n\n\n        var remainder = length - valueKeyframes.length;\n        remainder > 0 && utils.fillOffset(offset, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n\n        edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n\n\n  elementSequences.forEach(function (valueSequences, element) {\n    for (var _key in valueSequences) {\n      var _valueSequence = valueSequences[_key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n\n      _valueSequence.sort(sort.compareByTime);\n\n      var _keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n\n      for (var _i = 0; _i < _valueSequence.length; _i++) {\n        var _valueSequence$_i = _valueSequence[_i],\n            at = _valueSequence$_i.at,\n            value = _valueSequence$_i.value,\n            _easing = _valueSequence$_i.easing;\n\n        _keyframes.push(value);\n\n        valueOffset.push(utils.progress(0, totalDuration, at));\n        valueEasing.push(_easing || utils.defaults.easing);\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n\n\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n\n        _keyframes.unshift(_keyframes[0]);\n\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n\n\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n\n        _keyframes.push(null);\n      }\n\n      animationDefinitions.push([element, _key, _keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\n\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\n\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;","map":null,"metadata":{},"sourceType":"script"}